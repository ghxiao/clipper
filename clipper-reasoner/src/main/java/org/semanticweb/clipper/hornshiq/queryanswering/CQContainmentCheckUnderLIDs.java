package org.semanticweb.clipper.hornshiq.queryanswering;

import org.semanticweb.clipper.hornshiq.queryrewriting.CQGraph;
import org.semanticweb.clipper.hornshiq.queryrewriting.HomomorphismUtilities;
import org.semanticweb.clipper.hornshiq.queryrewriting.SubstitutionBuilder;
import org.semanticweb.clipper.hornshiq.rule.Atom;
import org.semanticweb.clipper.hornshiq.rule.CQ;
import org.semanticweb.clipper.hornshiq.rule.Predicate;

import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;


public class CQContainmentCheckUnderLIDs implements ICQGraphHomomorphismChecker {

    //private final OBDADataFactory fac = OBDADataFactoryImpl.getInstance();

    private final Map<CQ,IndexedCQ> indexedCQcache = new HashMap<>();

    //private final LinearInclusionDependencies dependencies;

    /***
     * Constructs a CQC utility using the given query. If Sigma is not null and
     * not empty, then it will also be used to verify containment w.r.t.\ Sigma.
     *
     */
    public CQContainmentCheckUnderLIDs() {
        //dependencies = null;
    }

    /**
     * *@param sigma
     * A set of ABox dependencies
     */
//    public CQContainmentCheckUnderLIDs(LinearInclusionDependencies dependencies) {
//        this.dependencies = dependencies;
//    }


    /**
     * This method is used to chase foreign key constraint rule in which the rule
     * has only one atom in the body.
     *
     * IMPORTANT: each rule is applied only ONCE to each atom
     *
     * @param atoms
     * @return set of atoms
     */
//    private Set<Atom> chaseAtoms(Collection<Atom> atoms) {
//
//        Set<Atom> derivedAtoms = new HashSet<>();
//        for (Atom fact : atoms) {
//            derivedAtoms.add(fact);
//            for (CQ rule : dependencies.getRules(fact.getPredicate())) {
//                rule = fac.getFreshCQCopy(rule);
//                Atom ruleBody = rule.getBody().get(0);
//                Substitution theta = UnifierUtilities.getMGU(ruleBody, fact);
//                if (theta != null && !theta.isEmpty()) {
//                    Atom ruleHead = rule.getHead();
//                    Atom newFact = (Atom)ruleHead.clone();
//                    // unify to get fact is needed because the dependencies are not necessarily full
//                    // (in other words, they may contain existentials in the head)
//                    SubstitutionUtilities.applySubstitution(newFact, theta);
//                    derivedAtoms.add(newFact);
//                }
//            }
//        }
//        return derivedAtoms;
//    }

    @Override
    public boolean isContainedIn(CQGraph g1, CQGraph g2) {
        return isContainedIn(g1.toCQ(), g2.toCQ());
    }

    public static final class IndexedCQ {

        private final Atom head;
        /***
         * An index of all the facts obtained by freezing this query.
         */
        private final Map<Predicate, List<Atom>> factMap;

        /***
         * Computes a query in which all terms have been replaced by
         * ValueConstants that have the no type and have the same 'name' as the
         * original variable.
         *
         * This new query can be used for query containment checking.
         *
         */

        public IndexedCQ(Atom head, Collection<Atom> body) {

            this.head = head;

            this.factMap = new HashMap<>(body.size() * 2);
            for (Atom atom : body)
                // not boolean, not algebra, not arithmetic, not datatype
                if (atom != null //&& atom.isDataAtom()
                        ) {
                    Predicate pred = atom.getPredicate();
                    List<Atom> facts = factMap.get(pred);
                    if (facts == null) {
                        facts = new LinkedList<Atom>();
                        factMap.put(pred, facts);
                    }
                    facts.add(atom);
                }
        }

        private Map computeHomomorphism(CQ query) {
            SubstitutionBuilder sb = new  SubstitutionBuilder();

            // get the substitution for the head first
            // it will ensure that all answer variables are mapped either to constants or
            //       to answer variables in the base (but not to the labelled nulls generated by the chase)
            boolean headResult = HomomorphismUtilities.extendHomomorphism(sb, query.getHead(), head);
            if (!headResult)
                return null;

            Map sub = HomomorphismUtilities.computeHomomorphism(sb, query.getBody(), factMap);

            return sub;
        }
    }


    /***
     * True if the first query is contained in the second query
     *    (in other words, the first query is more specific, it has fewer answers)
     *
     * @param q1
     * @param q2
     * @return true if the first query is contained in the second query
     */
    public boolean isContainedIn(CQ q1, CQ q2) {

        if (!q2.getHead().getPredicate().equals(q1.getHead().getPredicate()))
            return false;

        return (computeHomomorphsim(q1, q2) != null);
    }

    public Map computeHomomorphsim(CQGraph q1, CQGraph q2) {
        return computeHomomorphsim(q1.toCQ(), q2.toCQ());
    }

    public Map computeHomomorphsim(CQ q1, CQ q2) {

        IndexedCQ indexedQ1 = indexedCQcache.get(q1);
        if (indexedQ1 == null) {
            Collection<Atom> q1body = q1.getBody();
//            if (dependencies != null)
//                q1body = chaseAtoms(q1body);

            indexedQ1 = new IndexedCQ(q1.getHead(), q1body);
            indexedCQcache.put(q1, indexedQ1);
        }

        // just to speed up the check in case there can be no match
        for (Atom q2atom : q2.getBody())
            if (!indexedQ1.factMap.containsKey(q2atom.getPredicate())) {
                // in particular, !q2atom.isDataAtom()
                return null;
            }

        return indexedQ1.computeHomomorphism(q2);
    }

/*
	public CQ removeRedundantAtoms(CQ query) {
		List<Atom> nonRedundantAtoms = new ArrayList<>(query.getBody().size());

		Set<Variable> filterVariables = new HashSet<>();
		for (Atom atom : query.getBody())
			if (!atom.isDataAtom())
				filterVariables.addAll(atom.getVariables());

		for (Atom atom : query.getBody()) {
			if (atom.isDataAtom()) {
				boolean variableOccurrence = false;
				for (Variable term : atom.getVariables())
					if (filterVariables.contains(term)) {
						variableOccurrence = true;
						break;
					}
				if (variableOccurrence) {
					nonRedundantAtoms.add(atom);
					continue;
				}

				CQ clone = query.clone();
				clone.getBody().remove(atom);
				if (!isContainedIn(clone, query))
					nonRedundantAtoms.add(atom);
				else
					System.err.println("CQC REMOVED ATOM: " + atom + " FROM " + query);
			}
			else
				nonRedundantAtoms.add(atom);
		}

		return fac.getCQ(query.getHead(), nonRedundantAtoms);
	}
*/

//    @Override
//    public String toString() {
//        if (dependencies != null)
//            return dependencies.toString();
//
//        return "(empty)";
//    }
}
